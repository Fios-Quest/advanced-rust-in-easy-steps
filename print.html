<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Software Patterns and Coding Excellence</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Even more Rust idioms, patterns and useful tricks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Software Patterns and Coding Excellence</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtype"><a class="header" href="#newtype">NewType</a></h1>
<h2 id="what-is-a-type"><a class="header" href="#what-is-a-type">What is a type?</a></h2>
<p>If I show you this binary value, can you tell me what it is?</p>
<p><code>01000001 01010010 01101001 01000101 01010011 01000110 01010100 01010111</code></p>
<p>We can rule out a few things.</p>
<p>It’s 64bits, which means its definitely not a boolean or a character. It’s also too long for an IPv4 address, and too
short for an IPv6 address. More likely it’s a number, either a 64bit float <code>4826389.301167569123208522796630859375</code> or
a 64-bit integer <code>4706940307026367575</code>.</p>
<p>Or, if we run this code:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>let bytes = vec![
    0b01000001, 
    0b01010010, 
    0b01101001, 
    0b01000101, 
    0b01010011, 
    0b01000110, 
    0b01010100, 
    0b01010111,
];

let what_is_this_number = String::from_utf8(bytes)?;
println!("{what_is_this_number}");
<span class="boring">
</span><span class="boring">assert_eq!(what_is_this_number, String::from("ARiESFTW"));
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>It’s an advert for this book!</p>
<p>Types turn data into information. Without knowing whether we’re looking at a number or a sequence of ascii characters,
we’d have a really hard time writing code and, more importantly, what we write would be very error-prone.</p>
<p>Without type information, there’s nothing stopping us from accidentally passing a boolean to a function that expects
a complex user structure. We start having to depend constantly on runtime checks to make sure any data our functions
receive is valid before trying to process it.</p>
<p>All modern languages (even ones we may not usually think of being “typed”) come with their own built-in types that
usually cover at the very least, floats, strings, lists and objects (or dictionaries). This helps us reason about the
data stored in memory.</p>
<blockquote>
<p>You’ll notice I didn’t include integers in the bare minimum types, this is because some languages opt to store <em>all</em>
numbers as double precision floating points.</p>
</blockquote>
<p>But is it enough to consider <code>"hello@example.com"</code> to be a string? It technically is a string, sure, and we could
manipulate it as one, but, in the context of our software, it might be that there is a meaningful difference between
<code>"hello@example.com"</code> and <code>"Hello, example.com"</code>, in the same way as there is a meaningful difference between
<code>4706940307026367575</code> and <code>"ARiESFTW"</code>.</p>
<h2 id="whats-wrong-with-normal-types"><a class="header" href="#whats-wrong-with-normal-types">What’s wrong with normal types?</a></h2>
<p>A newtype (or new type, or in other languages, a value object), isn’t just a type that we create, but it’s specifically
a type that conveys more meaning around another type.</p>
<p>For example, if we wanted to represent years, months and days, we could do so with <code>u64</code>s:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>// Todays date as of writing:
let year: u64 = 2025;
let month: u64 = 9;
let day: u64 = 24;
<span class="boring">}</span></code></pre></pre>
<p>However, we can immediately identify some problems with this.</p>
<p>First, there’s nothing stopping us from using valid <code>u64</code>s to represent invalid data:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>let year: u64 = 22025;
let month: u64 = 19;
let day: u64 = 2400;
<span class="boring">}</span></code></pre></pre>
<p>Second, there’s nothing stopping us passing even a valid day to a function that’s supposed to take a month:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>fn get_english_month_name(month: u64) -&gt; String {
    // ...
<span class="boring">    match month  {
</span><span class="boring">        1 =&gt; "January".to_string(),
</span><span class="boring">        2 =&gt; "February".to_string(),
</span><span class="boring">        3 =&gt; "March".to_string(),
</span><span class="boring">        4 =&gt; "April".to_string(),
</span><span class="boring">        5 =&gt; "May".to_string(),
</span><span class="boring">        6 =&gt; "June".to_string(),
</span><span class="boring">        7 =&gt; "July".to_string(),
</span><span class="boring">        8 =&gt; "August".to_string(),
</span><span class="boring">        9 =&gt; "September".to_string(),
</span><span class="boring">        10 =&gt; "October".to_string(),
</span><span class="boring">        11 =&gt; "November".to_string(),
</span><span class="boring">        12 =&gt; "December".to_string(),
</span><span class="boring">        _ =&gt; "Invalid Month".to_string(),
</span><span class="boring">    }
</span>}

<span class="boring">let year: u64 = 2025;
</span><span class="boring">let month: u64 = 9;
</span><span class="boring">let day: u64 = 24;
</span><span class="boring">
</span>println!("{}", get_english_month_name(month));
println!("{}", get_english_month_name(day));
<span class="boring">assert_eq!(get_english_month_name(month), "September".to_string());
</span><span class="boring">assert_eq!(get_english_month_name(day), "Invalid Month".to_string());
</span><span class="boring">}</span></code></pre></pre>
<p>We need more context about the data. We need to know more about the “type” of data we’re dealing with beyond it just
being a number!</p>
<p>This is what the <code>newtype</code> pattern is for.</p>
<h2 id="introducing-newtype"><a class="header" href="#introducing-newtype">Introducing newtype</a></h2>
<p>First, lets prevent days being passed into functions that take months. We could do this by wrapping our <code>u64</code>s in tuple
structs, one for each of Year, Month and Day.</p>
<p>We can then modify our function that expect something that <em>is</em> a month to take the <code>Month</code> type. This is immediately
more informative to anyone reading your code.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span>struct Year(u64);
<span class="boring">#[derive(Copy, Clone)]
</span>struct Month(u64);
<span class="boring">#[derive(Copy, Clone)]
</span>struct Day(u64);

let year = Year(2025);
let month = Month(9);
let day = Day(24);

fn get_english_month_name(month: Month) -&gt; String {
    // ...
<span class="boring">    match month.0  {
</span><span class="boring">        1 =&gt; "January".to_string(),
</span><span class="boring">        2 =&gt; "February".to_string(),
</span><span class="boring">        3 =&gt; "March".to_string(),
</span><span class="boring">        4 =&gt; "April".to_string(),
</span><span class="boring">        5 =&gt; "May".to_string(),
</span><span class="boring">        6 =&gt; "June".to_string(),
</span><span class="boring">        7 =&gt; "July".to_string(),
</span><span class="boring">        8 =&gt; "August".to_string(),
</span><span class="boring">        9 =&gt; "September".to_string(),
</span><span class="boring">        10 =&gt; "October".to_string(),
</span><span class="boring">        11 =&gt; "November".to_string(),
</span><span class="boring">        12 =&gt; "December".to_string(),
</span><span class="boring">        _ =&gt; "Invalid Month".to_string(),
</span><span class="boring">    }
</span>}

// This will work
println!("{}", get_english_month_name(month));
<span class="boring">assert_eq!(get_english_month_name(month), "September".to_string());
</span>
// This won't compile, but gives a useful error message!
// println!("{}", get_english_month_name(day));
<span class="boring">}</span></code></pre></pre>
<p>If you try compiling the code with the last line uncommented, you get a wonderful error message:</p>
<pre><code class="language-text">   |
38 | println!("{}", get_english_month_name(day));
   |                ---------------------- ^^^ expected `Month`, found `Day`
   |                |
   |                arguments to this function are incorrect
   |
</code></pre>
<p>Our second issue is that we can still produce invalid values such as <code>Month(13)</code>. We can fix this by restricting the
instantiation of our types to a constructor, and validating the input. The question becomes, what should we do when
someone attempts to use invalid data, I would argue we should return a Result with a relevant error.</p>
<p>Let’s focus on <code>Month</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// First we need to make the interior of the struct private which means moving
// it into a separate module
mod month {
    pub struct Month(u64);

    pub struct InvalidMonthNumber;
    
    impl Month {
        pub fn from_number(month: u64) -&gt; Result&lt;Month, InvalidMonthNumber&gt; {
            if month &lt; 1 || month &gt; 12 {
                Err(InvalidMonthNumber)
            } else {
                Ok(Month(month))
            }
        }
    }
}

use month::Month;

<span class="boring">fn main() {
</span>let maybe_month = Month::from_number(0);
assert!(maybe_month.is_err());

let maybe_month = Month::from_number(9);
assert!(maybe_month.is_ok());
<span class="boring">}</span></code></pre></pre>
<p>I’d say there’s still one improvement we can make here, at least for months. Our program is written in English so why
use numbers to represent the months in our code. Furthermore, if we wanted to use the same <code>get_english_month_name</code>
function, by matching on the numeric value we still have to do <em>something</em> with a number that’s not 1-12.</p>
<p>We can change the code representation of our Month without changing its underlying numeric representation.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// First we need to make the interior of the struct private which means moving
// it into a separate module
mod month {
<span class="boring">    #[derive(Debug, PartialEq)]
</span>    #[repr(u64)]
    pub enum Month {
        January = 1,
        February = 2,
        March = 3,
        April = 4,
        May = 5,
        June = 6,
        July = 7,
        August = 8,
        September = 9,
        October = 10,
        November = 11,
        December = 12,
    }

<span class="boring">    #[derive(Debug)]
</span>    pub struct InvalidMonthNumber;
    
    impl Month {
        pub fn from_number(month: u64) -&gt; Result&lt;Month, InvalidMonthNumber&gt; {
            match month  {
                1 =&gt; Ok(Month::January),
                2 =&gt; Ok(Month::February),
                3 =&gt; Ok(Month::March),
                4 =&gt; Ok(Month::April),
                5 =&gt; Ok(Month::May),
                6 =&gt; Ok(Month::June),
                7 =&gt; Ok(Month::July),
                8 =&gt; Ok(Month::August),
                9 =&gt; Ok(Month::September),
                10 =&gt; Ok(Month::October),
                11 =&gt; Ok(Month::November),
                12 =&gt; Ok(Month::December),
                _ =&gt; Err(InvalidMonthNumber),
            }
        }

        pub fn get_english_month_name(&amp;self) -&gt; String {
            match self  {
                Month::January =&gt; "January".to_string(),
                Month::February =&gt; "February".to_string(),
                Month::March =&gt; "March".to_string(),
                Month::April =&gt; "April".to_string(),
                Month::May =&gt; "May".to_string(),
                Month::June =&gt; "June".to_string(),
                Month::July =&gt; "July".to_string(),
                Month::August =&gt; "August".to_string(),
                Month::September =&gt; "September".to_string(),
                Month::October =&gt; "October".to_string(),
                Month::November =&gt; "November".to_string(),
                Month::December =&gt; "December".to_string(),
            }
        }
    }
}

use month::Month;

<span class="boring">fn main() {
</span>let month = Month::from_number(9).expect("Somehow not September?!");
assert_eq!(month, Month::September);
println!("{}", month.get_english_month_name());
<span class="boring">assert_eq!(month.get_english_month_name(), "September".to_string());
</span><span class="boring">}</span></code></pre></pre>
<p>It’s worth point out that, these types only exist at compile time. In memory, in our running program, these types are
all exactly the same:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u64)]
pub enum MonthEnum {
    // ...snip
<span class="boring">    January = 1,
</span><span class="boring">    February = 2,
</span><span class="boring">    March = 3,
</span><span class="boring">    April = 4,
</span><span class="boring">    May = 5,
</span><span class="boring">    June = 6,
</span><span class="boring">    July = 7,
</span><span class="boring">    August = 8,
</span><span class="boring">    September = 9,
</span><span class="boring">    October = 10,
</span><span class="boring">    November = 11,
</span><span class="boring">    December = 12,
</span>}

pub struct MonthStruct(u64);

fn get_memory&lt;'a, T&gt;(input: &amp;'a T) -&gt; &amp;'a [u8] {
    // ...snip
<span class="boring">    // Credit: https://bennett.dev/rust/dump-struct-bytes/
</span><span class="boring">    unsafe {
</span><span class="boring">        std::slice::from_raw_parts(
</span><span class="boring">            input as *const _ as *const u8,
</span><span class="boring">            std::mem::size_of::&lt;T&gt;()
</span><span class="boring">        )
</span><span class="boring">    }
</span>}


let sept_num: u64 = 9;
let sept_struct = MonthStruct(9);
let sept_enum = MonthEnum::September;

let num_bytes = get_memory(&amp;sept_num);
let struct_bytes = get_memory(&amp;sept_struct);
let enum_bytes = get_memory(&amp;sept_enum);

println!("Num bytes: {num_bytes:?}");
println!("Struct bytes: {struct_bytes:?}");
println!("Enum bytes: {enum_bytes:?}");
<span class="boring">
</span><span class="boring">assert_eq!(num_bytes, struct_bytes);
</span><span class="boring">assert_eq!(struct_bytes, enum_bytes);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="tradeoffs"><a class="header" href="#tradeoffs">Tradeoffs?</a></h2>
<p>There seems to be a lot of extra work going on here. We need to add more validation, extra error types (and all the
extra work they’re supposed to involve that we skipped here), not to mention how verbose the match statements were for
the enum version of our month newtype.</p>
<p>That’s true.</p>
<p>But this is because we’re only looking at the newtype, not the impact that it has across your program.</p>
<p>By moving our validtion code to a single domain type, we’re decluttering the rest of our program.</p>
<p>Let’s think about a more complex type, like an email. Using built in types, we just create a validator and call it done:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_valid_email_address&lt;S&gt;(email: S) -&gt; bool
    where S: AsRef&lt;str&gt;
{
    let s = email.as_ref();
    // Must contain an @ that's not the first or last character
    s.contains('@')
        &amp;&amp; s.chars().next() != Some('@')
        &amp;&amp; s.chars().last() != Some('@')
}

// Tests
assert!(is_valid_email_address("a@b"));
assert!(!is_valid_email_address("@ab"));
assert!(!is_valid_email_address("ab@"));
<span class="boring">}</span></code></pre></pre>
<p>This code is simple and terse, and doesn’t require much testing. However, everytime we want to use a string as an email,
we will need to run the validator. This not only could risk the same email needing to be validated multiple times, but
adds some significant risk, particularly as our code evolves. Any time we <em>don’t</em> use the validator for a function that
accepts an email string because we perhaps initially create it only in a context where the string has already been
validated, we risk that function being reused with no validation later.</p>
<blockquote>
<p>It’s worth noting,  we’re using my “good enough, no false negatives” approach rather than a complex regex or parser,
which would be even more computationally expensive! See https://emailregex.com/ for a completely compliant regex
validation string but… the only way to really know if an email address is valid is to email it.</p>
</blockquote>
<p>Here’s a newtype representing an Email:</p>
<pre><pre class="playground"><code class="language-rust edition2024">mod email_address {
    use std::{fmt, error::Error};

    #[derive(Debug)]
    pub struct InvalidEmailAddressError;

    impl fmt::Display for InvalidEmailAddressError {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            write!(f, "Invalid Email Address")
        }
    }

    impl Error for InvalidEmailAddressError {}

    pub struct EmailAddress(String);

    impl EmailAddress {
        pub fn from_string&lt;S&gt;(email: S) -&gt; Result&lt;EmailAddress, InvalidEmailAddressError&gt;
            where S: ToString + AsRef&lt;str&gt;
        {
            match (Self::is_valid(&amp;email)) {
                true =&gt; Ok(EmailAddress(email.to_string())),
                false =&gt; Err(InvalidEmailAddressError),
            }
        }

        pub fn is_valid&lt;S&gt;(email: S) -&gt; bool
            where S: AsRef&lt;str&gt;
        {
            let s = email.as_ref();
            // Must contain an @ that's not the first or last character
            s.contains('@')
                &amp;&amp; s.chars().next() != Some('@')
                &amp;&amp; s.chars().last() != Some('@')
        }
    }
}

fn main() {
    use email_address::EmailAddress;

    // Tests
    let valid_email = EmailAddress::from_string("hello@example.com");
    let invalid_email = EmailAddress::from_string("Ted");

    assert!(valid_email.is_ok());
    assert!(invalid_email.is_err());

    assert!(EmailAddress::is_valid("a@b"));
    assert!(!EmailAddress::is_valid("@ab"));
    assert!(!EmailAddress::is_valid("ab@"));
}</code></pre></pre>
<p>We’ve had to implement an Error type for potentially invalid addresses, and a constructor… but our validator is
identical, and we only add two new tests.</p>
<p>Now, though, we only ever need to validate the email when we create the data type, which will usually be when we’re
getting that data from an external source, for example from a user or importing it from a database. This will also
likely be where we deal with any potential validation errors, further simplifying our code.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>For a small amount of extra work, newtypes give us:</p>
<ul>
<li>Centralised validation and error handling</li>
<li>Reduced complexity</li>
<li>More defensive code</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typestate"><a class="header" href="#typestate">Typestate</a></h1>
<p>The typestate pattern encodes state into type information. This is useful because this information exists when you
write the program but not when you run it, allowing you to enforce domain logic with minimal overhead.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Lets imagine a simplified pull request process. We can open a new pull request, which then must be approved by at least
one person, before it’s merged. Multiple people can approve it, but if anyone rejects it (even after its approved) it
can no longer be merged.</p>
<pre><code class="language-mermaid">%%{ init: { 'flowchart': {'defaultRenderer': 'elk' } } }%%
flowchart LR
    A ---&gt;|foo| B
    B ---&gt;|bar| B
</code></pre>
<pre><code class="language-mermaid">---
config:
  layout: elk
---
flowchart LR
    O[Open]
    A[Approved]
    R[Rejected]
    M[Merged]

    O -- Approve --&gt; A
    A -- Approve --&gt; A
    O -- Reject --&gt; R
    A -- Reject --&gt; R
    A -- Merge --&gt; M
</code></pre>
<p>Let’s try to model one small part of this flow in a traditional way, the “approve” action.</p>
<p>First lets model it with a PullRequest type that <em>has</em> a status. A PR can be approved if the status is ReadyForReview or
Approved. If the status was not one of those, then we’ll need to return an error to say that the status could not be
changed.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct InvalidStateError;

#[derive(Debug, PartialEq)]
enum Status {
    Open,
    Approved,
    Rejected,
    Merged
}

struct PullRequest {
    status: Status,
    // ...other PR details ...
}

impl PullRequest {
    fn approve(&amp;mut self) -&gt; Result&lt;(), InvalidStateError&gt; {
        if self.status == Status::Open || self.status == Status::Approved {
            self.status = Status::Approved;
            Ok(())
        } else {
            Err(InvalidStateError)
        }
    }

    fn reject(&amp;mut self) -&gt; Result&lt;(), InvalidStateError&gt; {
        if self.status == Status::Open || self.status == Status::Approved {
            self.status = Status::Rejected;
            Ok(())
        } else {
            Err(InvalidStateError)
        }
    }

    fn merge(&amp;mut self) -&gt; Result&lt;(), InvalidStateError&gt; {
        if self.status == Status::Approved {
            self.status = Status::Merged;
            Ok(())
        } else {
            Err(InvalidStateError)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main () {
</span>// You can approve a PR that's just been opened or already Approved
let mut pr = PullRequest { status: Status::Open };
assert!(pr.approve().is_ok());
assert_eq!(pr.status, Status::Approved);
assert!(pr.approve().is_ok());

// You can not approve or merge rejected PR
let mut pr = PullRequest { status: Status::Rejected };
assert!(pr.approve().is_err());
assert!(pr.merge().is_err());
<span class="boring">}</span></code></pre></pre>
<p>We’ve written up our three state change operations but we’ve had to write a lot of branching logic into each method to
check that the operation is only being run on a PR in a valid state. If it wasn’t in a valid state we produce errors
that now need to be dealt with.</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct PullRequestOpen {
    // ...other PR details ...
}

struct PullRequestApproved {
    // ...other PR details ...
}

struct PullRequestRejected {
    // ...other PR details ...
}

struct PullRequestMerged {
    // ...other PR details...
}

impl PullRequestOpen {
    fn approve(self) -&gt; PullRequestApproved {
        PullRequestApproved {
            // ... move self into PullRequestApproved ...
        }
    }

    fn reject(self) -&gt; PullRequestRejected {
        PullRequestRejected {
            // ... move self into PullRequestApproved ...
        }
    }
}

impl PullRequestApproved {
    fn approve(self) -&gt; PullRequestApproved {
        self
    }

    fn reject(self) -&gt; PullRequestRejected {
        PullRequestRejected {
            // ... move self into PullRequestApproved ...
        }
    }

    fn merge(self) -&gt; PullRequestMerged {
        PullRequestMerged {
            // ... move self into PullRequestApproved ...
        }
    }
}

<span class="boring">
</span><span class="boring">fn main () {
</span>let open_pr = PullRequestOpen { };

// You can not merge an open PR, the next line won't compile
// let merged_pr = open_pr.merge();

// You can approve a PR with Ready for Review or already Approved
let approved_pr = open_pr.approve();
let still_approved = approved_pr.approve();

// Then it can be merged
let merged_pr = still_approved.merge();

// The `.approve()` method doesn't exist for rejected PRs, commented line won't compile
let rejected_pr = PullRequestRejected { };
// rejected_pr.approve();
<span class="boring">}</span></code></pre></pre>
<h2 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h2>
<p>Utilising the typestate pattern requires writing a lot more code <em>but</em> that code has fewer branches, fewer (or in this
case no) potential error states, and everything is logically subdivided making maintaining the code more trivial.</p>
<p>In the example we’ve given here, we consume the type each time we change state. Generally in Rust it’s better to pass
references rather than ownership, but in the case of transitioning state we want to return a new type. Often the old
type will contain owned data that needs to be moved to the new type, and we’ll rarely want to keep the old state around
but your needs may differ. If you regularly need to keep the old state you could pass by reference, but if you only
occasionally need to keep the old state, you could clone it first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<p>The builder pattern allows us to construct complex types in steps.</p>
<p>For example, imagine we have a ‘User’ struct that holds a lot of information on a user. Some of that information is
required and some of it is not.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl From&lt;String&gt; for Username {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl From&lt;String&gt; for EmailAddress {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct User {
    // Required valus
    username: Username,
    primary_email: EmailAddress,
    // Optional values
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>There are arguably two versions of this pattern, a simpler version that will work in just about any language that I’m
going to refer to as “Builder Lite”, and a more complex version that only works in languages with strict generic typing,
the “<a href="patterns/./typestate.html">Typestate</a> Builder”. Each has their own pros and cons, and we’ll go over those too.</p>
<h2 id="builder-lite"><a class="header" href="#builder-lite">Builder Lite</a></h2>
<p>The traditional builder pattern uses a type that mirrors the type you want to build but everything is optional. We
use methods to update each field, and then have a finalizer that takes the data we’ve stored in the builder and attempts
to convert it into the target type.</p>
<p>For our <code>User</code> example that might look like this.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::error::Error;
use std::collections::HashSet;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for Username {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for EmailAddress {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct User {
</span><span class="boring">    // Required valus
</span><span class="boring">    username: Username,
</span><span class="boring">    primary_email: EmailAddress,
</span><span class="boring">    // Optional values
</span><span class="boring">    secondary_emails: HashSet&lt;EmailAddress&gt;,
</span><span class="boring">    phone_number: Option&lt;PhoneNumber&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>enum UserBuilderError {
    NoUsername,
    NoPrimaryEmail,
}


#[derive(Default)]
struct UserBuilder {
    username: Option&lt;Username&gt;,
    primary_email: Option&lt;EmailAddress&gt;,
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
}

impl UserBuilder {
    fn new() -&gt; Self {
        Self::default()
    }

    fn set_username(mut self, username: Username) -&gt; Self {
        self.username = Some(username);
        self
    }

    fn set_primary_email(mut self, email: EmailAddress) -&gt; Self {
        self.primary_email = Some(email);
        self
    }

    fn add_secondary_emaail(mut self, email: EmailAddress) -&gt; Self {
        self.secondary_emails.insert(email);
        self
    }

    fn set_phone_number(mut self, phone_number: PhoneNumber) -&gt; Self {
        self.phone_number = Some(phone_number);
        self
    }

    fn build(self) -&gt; Result&lt;User, UserBuilderError&gt; {
        let username = self.username.ok_or(UserBuilderError::NoUsername)?;
        let primary_email = self.primary_email.ok_or(UserBuilderError::NoPrimaryEmail)?;
        let secondary_emails = self.secondary_emails;
        let phone_number = self.phone_number;

        Ok (User {
            username,
            primary_email,
            secondary_emails,
            phone_number,            
        })
    }
}

fn main () {
    // We can successfully build a User if we have all the required information
    let user_result = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .set_primary_email(EmailAddress::from("fio@example.com"))
        .build();
    assert!(user_result.is_ok());

    // But if we don't give all the required information we get an error
    let user_result = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .build();
    assert!(user_result.is_err());
}</code></pre></pre>
<h2 id="typestate-builder"><a class="header" href="#typestate-builder">Typestate Builder</a></h2>
<p>In the previous example we need to deal with calling <code>.build()</code> on a builder that may not have all the required
information. To manage this potential problem we return a result. What if I told you, we can write this code in such
a way as to be sure that the <code>.build()</code> method can only be used once we can guarantee we have everything we need, thus
negating the Result requirement.</p>
<p>This is an advanced application of the <a href="patterns/./typestate.html">Typestate</a> pattern. Instead of migrating between concrete
types representing individual states, we can use generics as markers on top of which we can implement different methods</p>
<p>The only slight trick is that generic types must be “used” <em>in</em> our type. For example, the following won’t compile
because we didn’t use “T” in the struct itself, even though our instantiation uses a Unit Struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct BadExample&lt;T&gt; {
    data: String,
}

struct Marker;

<span class="boring">fn main() {
</span>let example = BadExample::&lt;Marker&gt; { data: "This won't work".to_string() };
<span class="boring">}</span></code></pre></pre>
<p>This is where <code>PhantomData</code> comes in. It’s a zero-sized marker that “uses” the types in generics, allowing you to use
generics as nothing more than a compile time marker.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::marker::PhantomData;

struct GoodExample&lt;T&gt; {
    data: String,
    marker_for_t: PhantomData&lt;T&gt;,
}

struct Marker;

<span class="boring">fn main() {
</span>let example = GoodExample::&lt;Marker&gt; {
    data: "This will work!".to_string(),
    marker_for_t: PhantomData,
};
<span class="boring">}</span></code></pre></pre>
<p>Let’s build our builder again using this method.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::error::Error;
use std::collections::HashSet;
use std::marker::PhantomData;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for Username {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for EmailAddress {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct User {
</span><span class="boring">    // Required valus
</span><span class="boring">    username: Username,
</span><span class="boring">    primary_email: EmailAddress,
</span><span class="boring">    // Optional values
</span><span class="boring">    secondary_emails: HashSet&lt;EmailAddress&gt;,
</span><span class="boring">    phone_number: Option&lt;PhoneNumber&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum UserBuilderError {
</span><span class="boring">    NoUsername,
</span><span class="boring">    NoPrimaryEmail,
</span><span class="boring">}
</span><span class="boring">
</span>
// We'll use these unit structs as markers for when values are set
// Deriving Default means we can simplify our constructor
#[derive(Default)]
struct Set;
#[derive(Default)]
struct Unset;

#[derive(Default)]
struct UserBuilder&lt;U, PE&gt; {
    username: Option&lt;Username&gt;,
    primary_email: Option&lt;EmailAddress&gt;,
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
    // We need to record the markers somewhere but this won't impact runtime
    username_set: PhantomData&lt;U&gt;,
    primary_email_set: PhantomData&lt;PE&gt;,
}

// The constructor only exists for UserBuilder&lt;Unset, Unset&gt; so that's how our
// builder starts
impl UserBuilder&lt;Unset, Unset&gt; {
    fn new() -&gt; UserBuilder&lt;Unset, Unset&gt; {
        Self::default()
    }
}

impl&lt;U, PE&gt; UserBuilder&lt;U, PE&gt; {
    // When we set the username we have to completely migrate the type and
    // create a new struct for the generics to work.
    fn set_username(mut self, username: Username) -&gt; UserBuilder&lt;Set, PE&gt; {
        UserBuilder {
            username: Some(username),
            primary_email: self.primary_email,
            secondary_emails: self.secondary_emails,
            phone_number: self.phone_number,
            username_set: PhantomData,
            primary_email_set: PhantomData,
        }
    }

    // Same goes for primary email
    fn set_primary_email(mut self, email: EmailAddress) -&gt; UserBuilder&lt;U, Set&gt; {
        UserBuilder {
            username: self.username,
            primary_email: Some(email),
            secondary_emails: self.secondary_emails,
            phone_number: self.phone_number,
            username_set: PhantomData,
            primary_email_set: PhantomData,
        }
    }

    // The other setters return the same type including generics, whatever they were before
    fn add_secondary_emaail(mut self, email: EmailAddress) -&gt; UserBuilder&lt;U, PE&gt; {
        self.secondary_emails.insert(email);
        self
    }

    fn set_phone_number(mut self, phone_number: PhoneNumber) -&gt; UserBuilder&lt;U, PE&gt; {
        self.phone_number = Some(phone_number);
        self
    }
}

// By only implementing `.build()` on UserBuilder&lt;Set, Set&gt;, the method will only
// be available once both `.set_username()` and `.set_primary_email()` are called.
impl UserBuilder&lt;Set, Set&gt; {
    fn build(self) -&gt; User {
        let username = self.username
            .expect("It should not be possible to call build with username unset");
        let primary_email = self.primary_email
            .expect("It should not be possible to call build with primary email unset");
        let secondary_emails = self.secondary_emails;
        let phone_number = self.phone_number;

        User {
            username,
            primary_email,
            secondary_emails,
            phone_number,
        }
    }
}

fn main () {
    // We can only build a User if we have all the required information
    let user = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .set_primary_email(EmailAddress::from("fio@example.com"))
        .build();

    // This won't compile because .build() only exists on UserBuilder&lt;Set, Set&gt;
    // let user_result = UserBuilder::new()
    //     .set_username(Username::from("Fio"))
    //     .build();
}</code></pre></pre>
<p>Using the typestate builder we prevent <code>.build()</code> being called unless all required data has been set. Rather than
runtime validation, we get compile time validation!</p>
<h2 id="pros-and-cons-1"><a class="header" href="#pros-and-cons-1">Pro’s and Con’s</a></h2>
<p>I don’t think there’s one “right” builder to use.</p>
<p>Having compile time validation that you’ve used the builder correctly is nice, but it adds a lot of complexity through
the type system, and you can arguably be sure you’ve used the builder correctly through tests. But using the lite
builder adds more complexity to your tests and error handling code.</p>
<p>Its also worth noting that the typestate builder won’t work if you can’t guarantee each method is called at runtime.
Methods that set a required parameter change the type of the builder, meaning you can’t put a call in a branch (such as
an if) because you can’t reconcile the types later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monads"><a class="header" href="#monads">Monads</a></h1>
<p>When programming, we are regularly take a value and perform some operation to get a new value.</p>
<p>Let’s say we have the value <code>5</code> which is an integer. We could square the value which gives us <code>25</code> which is still an
integer, or we could turn the value into a string which would give us <code>"5"</code> which is a different type.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main () {
</span>let twenty_five = 5 * 5;
let five = 5.to_string();

assert_eq!(twenty_five, 25);
assert_eq!(five, "5");
}</code></pre></pre>
<p>We might want to perform the same operation on any integer, so we create functions that can take <em>any</em> integer and
return our new value.</p>
<pre><pre class="playground"><code class="language-rust edition2024">// Don't worry that there are already built in ways to do this, 
// its for explanation only
fn square(input: i32) -&gt; i32 {
    input * input
}

fn to_string(input: i32) -&gt; String {
    format!("{input}")
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    assert_eq!(square(5), 25);
</span><span class="boring">    assert_eq!(to_string(5), "5".to_string());
</span><span class="boring">}</span></code></pre></pre>
<p>This shows to types of function:</p>
<ul>
<li>A function that maintains the input type: it takes a value of type <code>T</code> and returns a value of type <code>T</code>.
We’ll refer to this as <code>f(T) -&gt; T</code>.</li>
<li>A function that changes the input type: it takes a value of type <code>T</code> and returns a value of type <code>U</code>.
We’ll refer to this as <code>f(T) -&gt; T</code>.</li>
</ul>
<p>Typically with functions, we put the value into the function and get a value back out, but what if we reverse this.</p>
<p>What if we have a container for our value, we’ll call it <code>M</code>. <code>M</code> can contain any valid value of type <code>T</code> and could be
represented as <code>M&lt;T&gt;</code>. We still have our two types of function that can take a value of <code>T</code>, but they can’t take a value
of <code>M&lt;T&gt;</code> because it’s a different type.</p>
<p>What we could do instead is give the function to the container and ask it to apply it to the inner type.</p>
<p>If we start with <code>M&lt;T&gt;</code> and give it <code>f(T) -&gt; T</code> then the result is <code>M&lt;T&gt;</code>. But, if we start with <code>M&lt;T&gt;</code> and give it
<code>f(T) -&gt; U</code> then the result is <code>M&lt;U&gt;</code>.</p>
<p>In practice this might look like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn square(input: i32) -&gt; i32 {
</span><span class="boring">    input * input
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn to_string(input: i32) -&gt; String {
</span><span class="boring">    format!("{input}")
</span><span class="boring">}
</span><span class="boring">
</span>struct Container&lt;T&gt; {
    inner_value: T,
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn apply&lt;U, F: FnOnce(T) -&gt; U&gt;(self, f: F) -&gt; Container&lt;U&gt; {
        Container {
            inner_value: f(self.inner_value)
        }
    }
}

<span class="boring">fn main() {
</span>let five = Container { inner_value: 5 };
let result = five.apply(square).apply(to_string);
assert_eq!(result.inner_value, "25".to_string());
<span class="boring">}</span></code></pre></pre>
<h2 id="why-would-you-do-this"><a class="header" href="#why-would-you-do-this">Why would you do this?</a></h2>
<p>Our container, <code>M</code>, could contain more types. By delegating the work to the container type, we could allow our container
type to decide how (or even if) the function operates on its internal data.</p>
<p>Let’s try creating a container which contains two types, an arbitrary type <code>T</code>, and the unit type <code>()</code>. In this
container, when applying a function that takes <code>T</code> to our container, it only needs to apply it if the container contains
a value of type <code>T</code>, otherwis it can ignore it.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn square(input: i32) -&gt; i32 {
</span><span class="boring">    input * input
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn to_string(input: i32) -&gt; String {
</span><span class="boring">    format!("{input}")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq)]
</span>enum MaybeContainer&lt;T&gt; {
    ContainsSomething(T),
    ContainsNothing(())
}

impl&lt;T&gt; MaybeContainer&lt;T&gt; {
    fn apply&lt;U, F: FnOnce(T) -&gt; U&gt;(self, f: F) -&gt; MaybeContainer&lt;U&gt; {
        match self {
            Self::ContainsSomething(x) =&gt; MaybeContainer::ContainsSomething(f(x)),
            Self::ContainsNothing(()) =&gt; MaybeContainer::ContainsNothing(()),
        }
    }
}

<span class="boring">fn main() {
</span>let five = MaybeContainer::ContainsSomething(5);
let result = five.apply(square).apply(to_string);
assert_eq!(result, MaybeContainer::ContainsSomething("25".to_string()));

let nothing: MaybeContainer&lt;i32&gt; = MaybeContainer::ContainsNothing(());
let result = nothing.apply(square).apply(to_string);
assert_eq!(result, MaybeContainer::ContainsNothing(()));
<span class="boring">}</span></code></pre></pre>
<p>This looks a bit familiar right? Let’s quickly tidy this up:</p>
<ul>
<li>we don’t need to write in the unit type as its literally the type representation of nothing</li>
<li>the <code>apply</code> method name isn’t very specific, we always need a function that takes <code>T</code> and returns <code>U</code> (even if they’re
both the same type)</li>
<li>we’ll shorten the name of the container and its varints. It represents the concepts of something or nothing,
effectivily an optional type</li>
</ul>
<p>So maybe it should look more like this:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn square(input: i32) -&gt; i32 {
</span><span class="boring">    input * input
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn to_string(input: i32) -&gt; String {
</span><span class="boring">    format!("{input}")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq)]
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn apply&lt;U, F: FnOnce(T) -&gt; U&gt;(self, f: F) -&gt; Option&lt;U&gt; {
        match self {
            Self::Some(x) =&gt; Option::Some(f(x)),
            Self::None =&gt; Option::None,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">let five = Option::Some(5);
</span><span class="boring">let result = five.apply(square).apply(to_string);
</span><span class="boring">assert_eq!(result, Option::Some("25".to_string()));
</span><span class="boring">
</span><span class="boring">let nothing: Option&lt;i32&gt; = Option::None;
</span><span class="boring">let result = nothing.apply(square).apply(to_string);
</span><span class="boring">assert_eq!(result, Option::None);
</span><span class="boring">}</span></code></pre></pre>
<p>Yeap, we just recreated Rust’s <code>Option</code> type.</p>
<p>Our groups can contain more than something or nothing. They could contain a type that represents the concept of
successful execution, or an error, eg <code>Result&lt;T, E&gt;</code>. In Rust, the Result type generics, <code>T</code> and <code>E</code> could be the same
concrete type, for example, <code>String</code>. In order to differentiate them inside the result we have seperate functions
for applying functions to each; <code>map()</code>, and <code>map_err()</code>.</p>
<h2 id="rules--guidelines"><a class="header" href="#rules--guidelines">Rules / Guidelines</a></h2>
<p>The important thing for this kind of group is that:</p>
<ul>
<li>For a given group, a value representable as a type inside that group, should be convertable to that group without
its value changing. i.e. there must be a way of going from <code>T -&gt; m&lt;T&gt;</code> without the inner value changing.</li>
<li>There needs to be a way to apply a function to the inner types such that <code>f(T) -&gt; U</code> can be applied to <code>m&lt;T&gt;</code> to
produce <code>m&lt;U&gt;</code></li>
</ul>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<p>Encapsulating our values inside groups like this can significantly reduce the cognative overhead of our code, and its
a genuine shame that we’ve scared people off of this approach with complex naming and annotations.</p>
<p>Here are two piece of code written in typescript that demonstrate the power of nomads. We’ll create a function that
divides two numbers, but if the denominator is zero, we’ll treat it as no value. First we’ll implement the code without
monads:</p>
<pre><code class="language-typescript">const div = (denominator: number) =&gt; (numerator: number): number | null =&gt; {
    if (denominator == 0) {
        return null;
    }
    return numerator / denominator;
};

const add = (a: number) =&gt; (b: number) =&gt; a + b;

const div_zero = div(0);
const div_two = div(2);
const add_one = add(1);

let null_example = div_zero(6);
if (null_example !== null) {
    null_example = add_one(null_example);
}
if (null_example !== null) {
    null_example = div_zero(null_example);
}
if (null_example !== null) {
    // Won't get here
    console.log(null_example);
}

let num_example = div_two(6);
if (num_example !== null) {
    num_example = add_one(num_example);
}
if (num_example !== null) {
    num_example = div_two(num_example);
}
if (num_example !== null) {
    // Prints 2
    console.log(num_example);
}

console.log('done');
</code></pre>
<p>If we create a proxy for Rust’s Option type though (in this case we called it <code>Maybe</code>), this code gets much easier to
read.</p>
<pre><code class="language-typescript"># class Maybe&lt;T&gt; {
#     inner: T | null,
# 
#     public static some(value: T): Maybe&lt;T&gt; {
#         return new Maybe(value);
#     }
#
#     public static none(): Maybe&lt;T&gt; {
#         return new Maybe();
#     }
#
#     private constructor(value: T | null | undefined) {
#         if (value === undefined) {
#             this.inner = null;
#         } else {
#             this.inner = value;
#         }
#     }
#
#     public map&lt;U&gt;(f: (T) -&gt; U): Maybe&lt;U&gt; {
#         if (this.inner == null)  {
#             return new Maybe();
#         }
#         return new Maybe(f(this.inner))
#     }
#
#     public flatten&lt;U&gt;() -&gt; Maybe&lt;U&gt; {
#         if (this.inner instanceof Maybe) {
#             return this.inner.inner === null ?
#                 Maybe.none() :
#                 Maybe.some(this.inner.inner);
#         }
#         return this;
#     }
#
#     public and_then&lt;U&gt;(f: (T) -&gt; Maybe&lt;U&gt;) -&gt; Maybe&lt;U&gt; {
#         return this.map(f).flatten();
#     }
# }
#
const div = (denominator: number) =&gt; (numerator: number): Maybe&lt;number&gt; =&gt; {
    if (denominator == 0) {
        return Maybe.none();
    }
    return Maybe.some(numerator / denominator)
};

const add = (a: number) =&gt; (b: number) =&gt; a + b;

const div_zero = div(0);
const div_two = div(2);
const add_one = add(1);

div_zero(6)
    .map(add_one)
    .and_then(div_zero)
    .map(console.log); // Does nothing

div_zero(6)
    .map(add_one)
    .and_then(div_two)
    .map(console.log); // Prints 2

console.log('done');
</code></pre>
<p>In the first example, we have to deal with two seperate types, which means we constantly need to check what type we’re
dealing with. By encapsulating our different types into one group and having the logic that manages what to do for
different types managed inside that group, our code get’s far easier to read and comprehend!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
