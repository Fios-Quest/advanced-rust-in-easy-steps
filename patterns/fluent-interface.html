<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fluent Interface - Software Patterns and Coding Excellence</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Even more Rust idioms, patterns and useful tricks">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Software Patterns and Coding Excellence</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fluent-interface"><a class="header" href="#fluent-interface">Fluent Interface</a></h1>
<p>We often group data together into structs or objects.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">#[derive(Debug)]
</span>struct User {
    // This field will remain immutable
    username: Username,

    // We want to be able to change these fields
    pub email: Option&lt;Email&gt;,
    pub date_of_birth: Option&lt;DateOfBirth&gt;,
}

impl User {
    fn new(username: Username) -&gt; Self {
        Self {
            username,
            email: None,
            date_of_birth: None,
        }
    }
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span>let mut yuki = User::new(username);

yuki.email = Some(email);
yuki.date_of_birth = Some(date_of_birth);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>Depending on the nature of the data we might want to manage access through getters and setters, particularly if we need
to do any validation, or manipulation, etc. In our <code>User</code> example above, it might be good to not have to specify the
<code>Option</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">#[derive(Debug)]
</span>struct User {
    // Direct access to these properties is forbidden
    username: Username,
    email: Option&lt;Email&gt;,
    date_of_birth: Option&lt;DateOfBirth&gt;,
}

impl User {
    // ... snip ...
<span class="boring">    fn new(username: Username) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            username,
</span><span class="boring">            email: None,
</span><span class="boring">            date_of_birth: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span>
    fn set_email(&amp;mut self, email: Email) {
        self.email = Some(email)
    }

    fn set_date_of_birth(&amp;mut self, date_of_birth: DateOfBirth) {
        self.date_of_birth = Some(date_of_birth);
    }
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span>let mut yuki = User::new(username);

yuki.set_email(email);
yuki.set_date_of_birth(date_of_birth);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>However, this is still a little bit clunky as we have to refer to the underlying variable (<code>yuki</code>) multiple times.</p>
<p>We can make this more “fluent” simply by returning a reference to that object after each call of a setter. This allows
us to chain the setter methods, making the code clearer and easier to read.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">#[derive(Debug)]
</span>struct User {
    username: Username,
    email: Option&lt;Email&gt;,
    date_of_birth: Option&lt;DateOfBirth&gt;,
}

impl User {
    // ... snip ...
<span class="boring">    fn new(username: Username) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            username,
</span><span class="boring">            email: None,
</span><span class="boring">            date_of_birth: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span>
    fn set_email(&amp;mut self, email: Email) -&gt; &amp;mut Self {
        self.email = Some(email);
        self
    }

    fn set_date_of_birth(&amp;mut self, date_of_birth: DateOfBirth) -&gt; &amp;mut Self {
        self.date_of_birth = Some(date_of_birth);
        self
    }
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span>let mut yuki = User::new(username);

yuki.set_email(email)
    .set_date_of_birth(date_of_birth);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<h2 id="rust-quirks"><a class="header" href="#rust-quirks">Rust Quirks</a></h2>
<p>There are two quirks to this pattern that impact Rust specifically.</p>
<p>Firstly, this pattern works in many languages, and particularly in languages that use things like pass by reference and
copy on write by default, you can sort of stop thinking about it there. Rust has very specific memory management rules
to think about though.</p>
<p>This means we need to consider whether our fluent interface will use references or take and return ownership.</p>
<p>There are pros and cons to each approach.</p>
<p>Using references in our previous example, we need to make sure the owned data exists somewhere before we start modifying
it. That’s why we stored <code>yuki</code> first, then modified it, effectively two steps.</p>
<p>If we passed ownership back and forth instead, we could create a single chain:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct User {
</span><span class="boring">    username: Username,
</span><span class="boring">    email: Option&lt;Email&gt;,
</span><span class="boring">    date_of_birth: Option&lt;DateOfBirth&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl User {
    // ... snip ...
<span class="boring">    fn new(username: Username) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            username,
</span><span class="boring">            email: None,
</span><span class="boring">            date_of_birth: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span>
    fn set_email(mut self, email: Email) -&gt; Self {
        self.email = Some(email);
        self
    }

    fn set_date_of_birth(mut self, date_of_birth: DateOfBirth) -&gt; Self {
        self.date_of_birth = Some(date_of_birth);
        self
    }
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span>let yuki = User::new(username)
    .set_email(email)
    .set_date_of_birth(date_of_birth);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>In addition to this giving us a slightly nicer flow, you might notice that <code>yuki</code> doesn’t need to be mutable, we’re
encapsulating the mutability inside the methods where we need it.</p>
<p>However, there’s a downside to this too. If we <em>did</em> want to modify a single value, we’d have to make sure we take
ownership back from the method:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct User {
</span><span class="boring">    username: Username,
</span><span class="boring">    email: Option&lt;Email&gt;,
</span><span class="boring">    date_of_birth: Option&lt;DateOfBirth&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl User {
</span><span class="boring">    fn new(username: Username) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            username,
</span><span class="boring">            email: None,
</span><span class="boring">            date_of_birth: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_email(mut self, email: Email) -&gt; Self {
</span><span class="boring">        self.email = Some(email);
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_date_of_birth(mut self, date_of_birth: DateOfBirth) -&gt; Self {
</span><span class="boring">        self.date_of_birth = Some(date_of_birth);
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span><span class="boring">let yuki = User::new(username);
</span>let yuki = yuki.set_email(email);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>Which version you use will be up to you and likely depend on your circumstances. You could even mix and match (though
you will need to give the methods different names).</p>
<p>The other quirk is more of a nice touch. What if our setter could fail? Obviously, it’s Rust, we need to return a
<code>Result</code>. Luckily, the question mark operator allows us to unwrap an <code>Ok</code>, which means we can continue the chain so
long as we’re able to bubble the error.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Username(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Email(String);
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct DateOfBirth(String);
</span><span class="boring">impl DateOfBirth {
</span><span class="boring">    fn is_old_enough(&amp;self) -&gt; bool {
</span><span class="boring">        true
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct User {
</span><span class="boring">    username: Username,
</span><span class="boring">    email: Option&lt;Email&gt;,
</span><span class="boring">    date_of_birth: Option&lt;DateOfBirth&gt;,
</span><span class="boring">}
</span><span class="boring">struct NotOldEnoughError;
</span><span class="boring">impl From&lt;NotOldEnoughError&gt; for () {
</span><span class="boring">    fn from(value: NotOldEnoughError) -&gt; Self {
</span><span class="boring">        ()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl User {
    // ... snip ...
<span class="boring">    fn new(username: Username) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            username,
</span><span class="boring">            email: None,
</span><span class="boring">            date_of_birth: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_email(mut self, email: Email) -&gt; Self {
</span><span class="boring">        self.email = Some(email);
</span><span class="boring">        self
</span><span class="boring">    }
</span>
    fn set_dob(mut self, dob: DateOfBirth) -&gt; Result&lt;Self, NotOldEnoughError&gt; {
        if !dob.is_old_enough() {
            return Err(NotOldEnoughError);
        }
        self.date_of_birth = Some(dob);
        Ok(self)
    }
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), ()&gt; {
</span><span class="boring">let username = Username("Yuki".to_string());
</span><span class="boring">let date_of_birth = DateOfBirth("2009-05-01".to_string());
</span><span class="boring">let email = Email("yuki@example.com".to_string());
</span>let yuki = User::new(username)
    .set_dob(date_of_birth)? // we can continue the chain despite the result
    .set_email(email);
<span class="boring">println!("{yuki:#?}");
</span><span class="boring">Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>Using this pattern allows us to write much more readable code!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../patterns/typestate.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../patterns/builder.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../patterns/typestate.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../patterns/builder.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
