<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Builder - Advanced Rust In Easy Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Even more Rust idioms, patterns and useful tools">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advanced Rust In Easy Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="builder"><a class="header" href="#builder">Builder</a></h1>
<p>The builder pattern allows us to construct complex types in steps.</p>
<p>For example, imagine we have a ‘User’ struct that holds a lot of information on a user. Some of that information is
required and some of it is not.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl From&lt;String&gt; for Username {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl From&lt;String&gt; for EmailAddress {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct User {
    // Required valus
    username: Username,
    primary_email: EmailAddress,
    // Optional values
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>There are arguably two versions of this pattern, a simpler version that will work in just about any language that I’m
going to refer to as “Builder Lite”, and a more complex version that only works in languages, the
“<a href="./typestate.html">Typestate</a> Builder”. Each has their own pros and cons, and we’ll go over those too.</p>
<h2 id="builder-lite"><a class="header" href="#builder-lite">Builder Lite</a></h2>
<p>The traditional builder pattern uses a type that mirrors the type you want to build but everything is optional. We
use methods to update each field, and then have a finalizer that takes the data we’ve stored in the builder and attempts
to convert it into the target type.</p>
<p>For our <code>User</code> example that might look like this.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::error::Error;
use std::collections::HashSet;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for Username {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for EmailAddress {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct User {
</span><span class="boring">    // Required valus
</span><span class="boring">    username: Username,
</span><span class="boring">    primary_email: EmailAddress,
</span><span class="boring">    // Optional values
</span><span class="boring">    secondary_emails: HashSet&lt;EmailAddress&gt;,
</span><span class="boring">    phone_number: Option&lt;PhoneNumber&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>enum UserBuilderError {
    NoUsername,
    NoPrimaryEmail,
}


#[derive(Default)]
struct UserBuilder {
    username: Option&lt;Username&gt;,
    primary_email: Option&lt;EmailAddress&gt;,
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
}

impl UserBuilder {
    fn new() -&gt; Self {
        Self::default()
    }

    fn set_username(mut self, username: Username) -&gt; Self {
        self.username = Some(username);
        self
    }

    fn set_primary_email(mut self, email: EmailAddress) -&gt; Self {
        self.primary_email = Some(email);
        self
    }

    fn add_secondary_emaail(mut self, email: EmailAddress) -&gt; Self {
        self.secondary_emails.insert(email);
        self
    }

    fn set_phone_number(mut self, phone_number: PhoneNumber) -&gt; Self {
        self.phone_number = Some(phone_number);
        self
    }

    fn build(self) -&gt; Result&lt;User, UserBuilderError&gt; {
        let username = self.username.ok_or(UserBuilderError::NoUsername)?;
        let primary_email = self.primary_email.ok_or(UserBuilderError::NoPrimaryEmail)?;
        let secondary_emails = self.secondary_emails;
        let phone_number = self.phone_number;

        Ok (User {
            username,
            primary_email,
            secondary_emails,
            phone_number,            
        })
    }
}

fn main () {
    // We can successfully build a User if we have all the required information
    let user_result = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .set_primary_email(EmailAddress::from("fio@example.com"))
        .build();
    assert!(user_result.is_ok());

    // But if we don't give all the required information we get an error
    let user_result = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .build();
    assert!(user_result.is_err());
}</code></pre></pre>
<h2 id="typestate-builder"><a class="header" href="#typestate-builder">Typestate Builder</a></h2>
<p>In the previous example we need to deal with calling <code>.build()</code> on a builder that may not have all the required
information. To manage this potential problem we return a result. What if I told you, we can write this code in such
a way as to be sure that the <code>.build()</code> method can only be used once we can guarantee we have everything we need, thus
negating the Result requirement.</p>
<p>This is an advanced application of the <a href="./typestate.html">Typestate</a> pattern. Instead of migrating between concrete
types representing individual states, we can use generics as markers on top of which we can implement different methods</p>
<p>The only slight trick is that generic types must be “used” <em>in</em> our type. For example, the following won’t compile
because we didn’t use “T” in the struct itself, even though our instantiation uses a Unit Struct:</p>
<pre><pre class="playground"><code class="language-rust compile_fail edition2024">struct BadExample&lt;T&gt; {
    data: String,
}

struct Marker;

<span class="boring">fn main() {
</span>let example = BadExample::&lt;Marker&gt; { data: "This won't work".to_string() };
<span class="boring">}</span></code></pre></pre>
<p>This is where <code>PhantomData</code> comes in. It’s a zero-sized marker that “uses” the types in generics, allowing you to use
generics as nothing more than a compile time marker.</p>
<p>Let’s build our builder again using this method.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::error::Error;
use std::collections::HashSet;
use std::marker::PhantomData;

<span class="boring">// shush shush shush this code is supposed to look good, not be good
</span><span class="boring">struct Username(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for Username {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Eq, PartialEq, Hash)]
</span><span class="boring">struct EmailAddress(String);
</span><span class="boring">impl&lt;S: ToString&gt; From&lt;S&gt; for EmailAddress {
</span><span class="boring">    fn from(s: S) -&gt; Self  {
</span><span class="boring">        Self(s.to_string())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">struct PhoneNumber(String);
</span><span class="boring">impl From&lt;String&gt; for PhoneNumber {
</span><span class="boring">    fn from(s: String) -&gt; Self  {
</span><span class="boring">        Self(s)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct User {
</span><span class="boring">    // Required valus
</span><span class="boring">    username: Username,
</span><span class="boring">    primary_email: EmailAddress,
</span><span class="boring">    // Optional values
</span><span class="boring">    secondary_emails: HashSet&lt;EmailAddress&gt;,
</span><span class="boring">    phone_number: Option&lt;PhoneNumber&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum UserBuilderError {
</span><span class="boring">    NoUsername,
</span><span class="boring">    NoPrimaryEmail,
</span><span class="boring">}
</span><span class="boring">
</span>
// We'll use these unit structs as markers for when values are set
// Deriving Default means we can simplify our constructor
#[derive(Default)]
struct Set;
#[derive(Default)]
struct Unset;

#[derive(Default)]
struct UserBuilder&lt;U, PE&gt; {
    username: Option&lt;Username&gt;,
    primary_email: Option&lt;EmailAddress&gt;,
    secondary_emails: HashSet&lt;EmailAddress&gt;,
    phone_number: Option&lt;PhoneNumber&gt;,
    // We need to record the markers somewhere but this won't impact runtime
    username_set: PhantomData&lt;U&gt;,
    primary_email_set: PhantomData&lt;PE&gt;,
}

// The constructor only exists for UserBuilder&lt;Unset, Unset&gt; so that's how our
// builder starts
impl UserBuilder&lt;Unset, Unset&gt; {
    fn new() -&gt; UserBuilder&lt;Unset, Unset&gt; {
        Self::default()
    }
}

impl&lt;U, PE&gt; UserBuilder&lt;U, PE&gt; {
    // When we set the username we have to completely migrate the type and
    // create a new struct for the generics to work.
    fn set_username(mut self, username: Username) -&gt; UserBuilder&lt;Set, PE&gt; {
        UserBuilder {
            username: Some(username),
            primary_email: self.primary_email,
            secondary_emails: self.secondary_emails,
            phone_number: self.phone_number,
            username_set: PhantomData,
            primary_email_set: PhantomData,
        }
    }

    // Same goes for primary email
    fn set_primary_email(mut self, email: EmailAddress) -&gt; UserBuilder&lt;U, Set&gt; {
        UserBuilder {
            username: self.username,
            primary_email: Some(email),
            secondary_emails: self.secondary_emails,
            phone_number: self.phone_number,
            username_set: PhantomData,
            primary_email_set: PhantomData,
        }
    }

    // The other setters return the same type including generics, whatever they were before
    fn add_secondary_emaail(mut self, email: EmailAddress) -&gt; UserBuilder&lt;U, PE&gt; {
        self.secondary_emails.insert(email);
        self
    }

    fn set_phone_number(mut self, phone_number: PhoneNumber) -&gt; UserBuilder&lt;U, PE&gt; {
        self.phone_number = Some(phone_number);
        self
    }
}

// By only implementing `.build()` on UserBuilder&lt;Set, Set&gt;, the method will only
// be available once both `.set_username()` and `.set_primary_email()` are called.
impl UserBuilder&lt;Set, Set&gt; {
    fn build(self) -&gt; User {
        let username = self.username
            .expect("It should not be possible to call build with username unset");
        let primary_email = self.primary_email
            .expect("It should not be possible to call build with primary email unset");
        let secondary_emails = self.secondary_emails;
        let phone_number = self.phone_number;

        User {
            username,
            primary_email,
            secondary_emails,
            phone_number,
        }
    }
}

fn main () {
    // We can only build a User if we have all the required information
    let user = UserBuilder::new()
        .set_username(Username::from("Fio"))
        .set_primary_email(EmailAddress::from("fio@example.com"))
        .build();

    // This won't compile because .build() only exists on UserBuilder&lt;Set, Set&gt;
    // let user_result = UserBuilder::new()
    //     .set_username(Username::from("Fio"))
    //     .build();
}</code></pre></pre>
<p>Using the typestate builder we prevent <code>.build()</code> being called unless all required data has been set. Rather than
runtime validation, we get compile time validation!</p>
<h2 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pro’s and Con’s</a></h2>
<p>I don’t think there’s one “right” builder to use.</p>
<p>Having compile time validation that you’ve used the builder correctly is nice, but it adds a lot of complexity through
the type system, and you can arguably be sure you’ve used the builder correctly through tests. But using the lite
builder adds more complexity to your tests and error handling code.</p>
<p>Its also worth noting that the typestate builder won’t work if you can’t guarantee each method is called at runtime.
Methods that set a required parameter change the type of the builder, meaning you put a call in a branch (such as an if)
you can’t reconcile the types later.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../patterns/typestate.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../patterns/typestate.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
